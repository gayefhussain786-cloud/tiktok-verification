<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Gesture Particle Morph</title>

<style>
body { margin:0; overflow:hidden; background:#000; font-family:sans-serif; }
#container { position:absolute; inset:0; }
canvas { display:block; }
.ui {
    position:absolute; top:20px; left:20px;
    color:#0ff; z-index:6; pointer-events:none;
    text-shadow:0 0 8px #000;
}
#webcam {
    position:absolute; bottom:10px; right:10px;
    width:200px; border:2px solid #0ff;
    border-radius:10px; transform:scaleX(-1);
    z-index:5; pointer-events:none;
}
</style>
</head>

<body>

<div class="ui">
<h1>Gesture Particle System</h1>
<p>üñê Open Palm</p>
<p>‚úåÔ∏è Peace </p>
<p>‚ù§Ô∏è Pinch </p>
<p>‚è≥ No hand 2s ‚Üí RESET</p>
<p>‚Üî Zoom ‚Üí Hand distance</p>
</div>

<video id="webcam" autoplay></video>
<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
let scene, camera, renderer, particles;
const particleCount = 6000;

let currentShape = 'random';
let lastHandTime = performance.now();
let handPresent = false;

let shapeCenter = new THREE.Vector3();
let stableCenter = new THREE.Vector3();
let stableInitialized = false;

let targetZoom = 1;

// ---------- THREE ----------
function initThree() {
    
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 6;
    camera.zoom = 1;
    camera.updateProjectionMatrix();

    renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(innerWidth, innerHeight);
    container.appendChild(renderer.domElement);

    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount * 3);
    const col = new Float32Array(particleCount * 3);

    for(let i=0;i<particleCount;i++){
        pos[i*3]   = (Math.random()-0.5)*15;
        pos[i*3+1] = (Math.random()-0.5)*15;
        pos[i*3+2] = (Math.random()-0.5)*15;

        col[i*3]   = 0.5 + Math.random() * 0.5;
        col[i*3+1] = 0.5 + Math.random() * 0.5;
        col[i*3+2] = 0.5 + Math.random() * 0.5;

    }

    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geo.setAttribute('color', new THREE.BufferAttribute(col,3));

    particles = new THREE.Points(
        geo,
        new THREE.PointsMaterial({
            size:0.06,
            vertexColors:true,
            transparent:true,
            opacity:0.95,
            blending:THREE.AdditiveBlending
        })
    );
    scene.add(particles);
}

// ---------- SHAPES ----------

// ‚ù§Ô∏è FULL 3D HEART
function getHeartPoint(t){
    t *= Math.PI * 2;
    const r = Math.random() * 0.8 + 0.2; // fill heart
    return {
        x:16*Math.pow(Math.sin(t),3)*0.12*r,
        y:(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*0.12*r,
        z:(Math.random()-0.5)*0.8
    };
}
function getTextPoints(text){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = 800;
    canvas.height = 300;

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width/2, canvas.height/2);

    const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    const points = [];

    for(let y=0;y<canvas.height;y+=3){
        for(let x=0;x<canvas.width;x+=3){
            if(img[(y*canvas.width+x)*4] > 200){
                points.push({
                    x:(x-canvas.width/2)*0.015,
                    y:(canvas.height/2-y)*0.015,
                    z:(Math.random()-0.5)*0.6
                });
            }
        }
    }
    return points;
}

const text1 = getTextPoints("ILOVEYOU");
const text2 = getTextPoints("BABYJI");

// ---------- MORPH ----------
function morphTo(shape){
    if(currentShape === shape) return;
    currentShape = shape;

    const pos = particles.geometry.attributes.position;
    const col = particles.geometry.attributes.color;

    for(let i=0;i<particleCount;i++){
        let t, c;

        if(shape === 'heart'){
            t = getHeartPoint(i/particleCount);
            c = [1.0, 0.2, 0.3];   // ‚ù§Ô∏è rich red
        }
        else if(shape === 'text1'){
            t = text1[i % text1.length];
            c = [0.3, 1.0, 1.0];  // cyan
        }
        else if(shape === 'text2'){
            t = text2[i % text2.length];
            c = [0.4, 0.3, 1.0];  // üîµ vivid blue (NOT white)
        }
        else {
            t = {
                x:(Math.random()-0.5)*12,
                y:(Math.random()-0.5)*12,
                z:(Math.random()-0.5)*12
            };
            c = [
                0.5 + Math.random()*0.5,
                0.5 + Math.random()*0.5,
                0.5 + Math.random()*0.5
            ];
        }

        gsap.to(pos.array,{
            [i*3]:t.x,[i*3+1]:t.y,[i*3+2]:t.z,
            duration:1.5,
            ease:"power2.inOut",
            onUpdate:()=>pos.needsUpdate=true
        });

        col.array[i*3]   = c[0];
        col.array[i*3+1] = c[1];
        col.array[i*3+2] = c[2];
    }

    col.needsUpdate = true;
}

// ---------- HAND TRACKING ----------
const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});

hands.onResults(r=>{
    if(!r.multiHandLandmarks?.length) return;

    lastHandTime=performance.now();
    handPresent=true;

    const h=r.multiHandLandmarks[0];
    const wrist=h[0], index=h[8], thumb=h[4], middle=h[12], pinky=h[20];

    const palmX=(wrist.x+h[5].x+h[9].x+h[13].x+h[17].x)/5;
    const palmY=(wrist.y+h[5].y+h[9].y+h[13].y+h[17].y)/5;

    shapeCenter.set(-(palmX-0.5)*10, -(palmY-0.5)*10, 0);

    if(!stableInitialized){
        stableCenter.copy(shapeCenter);
        stableInitialized=true;
    }

    stableCenter.lerp(shapeCenter,0.2);
    particles.position.copy(stableCenter);

    const handSpan = Math.hypot(h[5].x-h[17].x,h[5].y-h[17].y);
    targetZoom = THREE.MathUtils.clamp(handSpan*6,0.6,4);

    if(Math.hypot(index.x-thumb.x,index.y-thumb.y)<0.05) morphTo('heart');
    else if(Math.hypot(index.x-middle.x,index.y-middle.y)<0.08 && pinky.y>h[17].y) morphTo('text2');
    else if(pinky.y<wrist.y-0.2) morphTo('text1');
});

new Camera(webcam,{
    onFrame:async()=>await hands.send({image:webcam}),
    width:640,height:480
}).start();

// ---------- ANIMATE ----------
initThree();

function animate(){
    requestAnimationFrame(animate);

    camera.zoom += (targetZoom-camera.zoom)*0.12;
    camera.updateProjectionMatrix();

    particles.rotation.y += 0.005;

    if(handPresent && performance.now()-lastHandTime>2000){
        morphTo('random');
        handPresent=false;
        stableInitialized=false;
    }

    renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
